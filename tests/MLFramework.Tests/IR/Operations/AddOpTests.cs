using NUnit.Framework;
using MLFramework.IR;
using MLFramework.IR.HLIR.Elementwise;
using MLFramework.IR.Types;
using MLFramework.IR.Values;

namespace MLFramework.Tests.IR.Operations
{
    [TestFixture]
    public class AddOpTests
    {
        private IRContext _context;

        [SetUp]
        public void Setup()
        {
            _context = new IRContext();
        }

        [Test]
        public void AddOp_CreatesCorrectOperation()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var resultType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType, "lhs");
            var rhs = _context.CreateValue(rhsType, "rhs");
            var result = _context.CreateValue(resultType, "result");

            var addOp = new AddOp(lhs, rhs, result);

            Assert.AreEqual(lhs, addOp.Lhs);
            Assert.AreEqual(rhs, addOp.Rhs);
            Assert.AreEqual(result, addOp.Result);
        }

        [Test]
        public void AddOp_Validate_DoesNotThrowForValidShapes()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(lhsType);

            var addOp = new AddOp(lhs, rhs, result);

            Assert.DoesNotThrow(() => addOp.Validate());
        }

        [Test]
        public void AddOp_Validate_ThrowsForIncompatibleShapes()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 128 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(lhsType);

            var addOp = new AddOp(lhs, rhs, result);

            Assert.Throws<System.InvalidOperationException>(() => addOp.Validate());
        }

        [Test]
        public void AddOp_Validate_ThrowsForDifferentElementTypes()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Int32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(lhsType);

            var addOp = new AddOp(lhs, rhs, result);

            Assert.Throws<System.InvalidOperationException>(() => addOp.Validate());
        }

        [Test]
        public void AddOp_Validate_DoesNotThrowForBroadcastableShapes()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 1, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(lhsType);

            var addOp = new AddOp(lhs, rhs, result);

            Assert.DoesNotThrow(() => addOp.Validate());
        }

        [Test]
        public void AddOp_Construction_ThrowsForNullLhs()
        {
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(rhsType);

            Assert.Throws<System.ArgumentNullException>(() =>
                new AddOp(null, rhs, result));
        }

        [Test]
        public void AddOp_Construction_ThrowsForNullRhs()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var result = _context.CreateValue(lhsType);

            Assert.Throws<System.ArgumentNullException>(() =>
                new AddOp(lhs, null, result));
        }

        [Test]
        public void AddOp_Construction_ThrowsForNullResult()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);

            Assert.Throws<System.ArgumentNullException>(() =>
                new AddOp(lhs, rhs, null));
        }

        [Test]
        public void AddOp_Create_CreatesOperationWithAutoGeneratedResult()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);

            var result = AddOp.Create(_context, lhs, rhs, "result");

            Assert.IsNotNull(result);
            Assert.AreEqual("result", result.Name);

            // Verify operation was registered
            var ops = _context.GetAllOperations();
            Assert.AreEqual(1, ops.Count);
        }

        [Test]
        public void AddOp_Create_InfersBroadcastShape()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 1, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);

            var result = AddOp.Create(_context, lhs, rhs);

            Assert.IsNotNull(result);
            Assert.IsInstanceOf<TensorType>(result.Type);
            var resultType = (TensorType)result.Type;
            Assert.AreEqual(new[] { 32, 64 }, resultType.Shape);
        }

        [Test]
        public void AddOp_Create_ThrowsForIncompatibleShapes()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 128 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);

            Assert.Throws<System.InvalidOperationException>(() =>
                AddOp.Create(_context, lhs, rhs));
        }

        [Test]
        public void AddOp_Clone_CreatesIndependentCopy()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var resultType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(resultType);

            var original = new AddOp(lhs, rhs, result);
            var cloned = (AddOp)original.Clone();

            Assert.AreEqual(original.Lhs, cloned.Lhs);
            Assert.AreEqual(original.Rhs, cloned.Rhs);
            Assert.AreEqual(original.Result, cloned.Result);
        }

        [Test]
        public void AddOp_Validate_ThrowsForNonTensorLhs()
        {
            var lhs = _context.CreateValue(new Attributes.ScalarType(DataType.Float32));
            var rhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var rhs = _context.CreateValue(rhsType);
            var result = _context.CreateValue(rhsType);

            var addOp = new AddOp(lhs, rhs, result);

            Assert.Throws<System.InvalidOperationException>(() => addOp.Validate());
        }

        [Test]
        public void AddOp_Validate_ThrowsForNonTensorRhs()
        {
            var lhsType = new TensorType(DataType.Float32, new[] { 32, 64 });
            var lhs = _context.CreateValue(lhsType);
            var rhs = _context.CreateValue(new Attributes.ScalarType(DataType.Float32));
            var result = _context.CreateValue(lhsType);

            var addOp = new AddOp(lhs, rhs, result);

            Assert.Throws<System.InvalidOperationException>(() => addOp.Validate());
        }
    }
}
