using NUnit.Framework;
using MLFramework.IR.Graph;
using MLFramework.IR.Types;

namespace MLFramework.Tests.IR.Graph
{
    [TestFixture]
    public class HLIRGraphBuilderTests
    {
        private HLIRModule _module;

        [SetUp]
        public void Setup()
        {
            _module = new HLIRModule();
        }

        [Test]
        public void IRBlock_CreateWithValidName()
        {
            var block = new IRBlock("TestBlock");

            Assert.AreEqual("TestBlock", block.Name);
            Assert.IsNotNull(block.Operations);
            Assert.IsNotNull(block.Arguments);
            Assert.IsNotNull(block.Returns);
            Assert.AreEqual(0, block.Operations.Count);
            Assert.AreEqual(0, block.Arguments.Count);
            Assert.AreEqual(0, block.Returns.Count);
        }

        [Test]
        public void IRBlock_CreateWithAutoGeneratedName()
        {
            var block = new IRBlock();

            Assert.IsNotNull(block.Name);
            Assert.IsTrue(block.Name.StartsWith("block"));
        }

        [Test]
        public void IRBlock_AddOperation_AddsOperationToBlock()
        {
            var block = new IRBlock("TestBlock");
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            // Create a simple operation (add)
            var builder = new HLIRBuilder(func);
            var result = builder.Add(input, input, "test");

            Assert.AreEqual(1, block.Operations.Count);
        }

        [Test]
        public void IRBlock_AddArgument_AddsArgumentToBlock()
        {
            var block = new IRBlock("TestBlock");
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = _module.Context.CreateValue(inputType, "x");

            block.AddArgument(input);

            Assert.AreEqual(1, block.Arguments.Count);
            Assert.AreEqual(input, block.Arguments[0]);
        }

        [Test]
        public void IRBlock_AddReturn_AddsReturnValueToBlock()
        {
            var block = new IRBlock("TestBlock");
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var result = builder.Add(input, input, "result");

            block.AddReturn(result);

            Assert.AreEqual(1, block.Returns.Count);
            Assert.AreEqual(result, block.Returns[0]);
        }

        [Test]
        public void HLIRFunction_CreateWithValidName()
        {
            var func = _module.CreateFunction("TestFunction");

            Assert.AreEqual("TestFunction", func.Name);
            Assert.IsNotNull(func.Parameters);
            Assert.IsNotNull(func.Results);
            Assert.IsNotNull(func.Body);
        }

        [Test]
        public void HLIRFunction_AddParameter_AddsParameter()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });

            var param = func.AddParameter(inputType, "x");

            Assert.AreEqual(1, func.Parameters.Count);
            Assert.AreEqual("x", param.Name);
        }

        [Test]
        public void HLIRFunction_SetResults_SetsResults()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var result = builder.Add(input, input, "result");

            func.SetResults(result);

            Assert.AreEqual(1, func.Results.Count);
            Assert.AreEqual(result, func.Results[0]);
        }

        [Test]
        public void HLIRModule_Create_CreatesEmptyModule()
        {
            var module = new HLIRModule();

            Assert.IsNotNull(module.Context);
            Assert.IsNotNull(module.Functions);
            Assert.IsNotNull(module.Constants);
            Assert.AreEqual(0, module.Functions.Count);
            Assert.AreEqual(0, module.Constants.Count);
        }

        [Test]
        public void HLIRModule_CreateFunction_AddsFunction()
        {
            var func = _module.CreateFunction("TestFunc");

            Assert.AreEqual(1, _module.Functions.Count);
            Assert.AreEqual("TestFunc", func.Name);
        }

        [Test]
        public void HLIRModule_AddConstant_AddsConstant()
        {
            var value = new MLFramework.IR.Attributes.FloatAttribute(3.14f);
            _module.AddConstant("pi", value);

            Assert.AreEqual(1, _module.Constants.Count);
            var retrieved = _module.GetConstant("pi");
            Assert.IsNotNull(retrieved);
        }

        [Test]
        public void HLIRBuilder_CreateWithFunction_CreatesBuilder()
        {
            var func = _module.CreateFunction("TestFunc");
            var builder = new HLIRBuilder(func);

            Assert.AreEqual(func, builder.CurrentFunction);
            Assert.AreEqual(func.Body, builder.CurrentBlock);
        }

        [Test]
        public void HLIRBuilder_CreateWithModule_CreatesFunction()
        {
            var builder = new HLIRBuilder(_module);

            Assert.IsNotNull(builder.CurrentFunction);
            Assert.IsNotNull(builder.CurrentBlock);
        }

        [Test]
        public void HLIRBuilder_Add_CreatesAddOperation()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var result = builder.Add(input, input, "result");

            Assert.IsNotNull(result);
            Assert.AreEqual(1, func.Body.Operations.Count);
        }

        [Test]
        public void HLIRBuilder_MatMul_CreatesMatMulOperation()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var weightType = new TensorType(DataType.Float32, new[] { 784, 256 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var weight = _module.Context.CreateValue(weightType, "w");
            var result = builder.MatMul(input, weight, false, false, "h");

            Assert.IsNotNull(result);
        }

        [Test]
        public void HLIRBuilder_ReLU_CreatesReLUOperation()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var result = builder.ReLU(input, "output");

            Assert.IsNotNull(result);
            Assert.AreEqual(1, func.Body.Operations.Count);
        }

        [Test]
        public void HLIRBuilder_Reshape_CreatesReshapeOperation()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var newShape = new[] { 32, 28, 28 };
            var result = builder.Reshape(input, newShape, "reshaped");

            Assert.IsNotNull(result);
            Assert.AreEqual(1, func.Body.Operations.Count);
        }

        [Test]
        public void HLIRGraphAnalyzer_FindInputs_ReturnsParameters()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            func.AddParameter(inputType, "x");

            var inputs = HLIRGraphAnalyzer.FindInputs(func);

            Assert.AreEqual(1, inputs.Count);
            Assert.AreEqual("x", inputs[0].Name);
        }

        [Test]
        public void HLIRGraphAnalyzer_FindOutputs_ReturnsResults()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var result = builder.Add(input, input, "output");
            func.SetResults(result);

            var outputs = HLIRGraphAnalyzer.FindOutputs(func);

            Assert.AreEqual(1, outputs.Count);
            Assert.AreEqual(result, outputs[0]);
        }

        [Test]
        public void HLIRGraphAnalyzer_ValidateGraph_ReturnsTrueForValidGraph()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var result = builder.Add(input, input, "output");
            func.SetResults(result);

            var isValid = HLIRGraphAnalyzer.ValidateGraph(func);

            Assert.IsTrue(isValid);
        }

        [Test]
        public void HLIRGraphAnalyzer_CountOperations_ReturnsCorrectCount()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            builder.Add(input, input, "op1");
            builder.Add(input, input, "op2");
            builder.Add(input, input, "op3");

            var count = HLIRGraphAnalyzer.CountOperations(func);

            Assert.AreEqual(3, count);
        }

        [Test]
        public void HLIRGraphAnalyzer_GetOperationStats_ReturnsStatistics()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            builder.Add(input, input, "add1");
            builder.Add(input, input, "add2");
            builder.MatMul(input, input, "matmul1");

            var stats = HLIRGraphAnalyzer.GetOperationStats(func);

            Assert.IsTrue(stats.Count > 0);
        }

        [Test]
        public void BuildSimpleNeuralNetwork_UsingBuilder()
        {
            var func = _module.CreateFunction("SimpleNN");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var weight1Type = new TensorType(DataType.Float32, new[] { 784, 128 });
            var weight2Type = new TensorType(DataType.Float32, new[] { 128, 10 });

            var input = func.AddParameter(inputType, "x");
            var builder = new HLIRBuilder(func);

            var w1 = _module.Context.CreateValue(weight1Type, "w1");
            var h1 = builder.ReLU(builder.MatMul(input, w1, false, false, "matmul1"));

            var w2 = _module.Context.CreateValue(weight2Type, "w2");
            var output = builder.MatMul(h1, w2, false, false, "output");

            func.SetResults(output);

            Assert.AreEqual(1, func.Parameters.Count);
            Assert.AreEqual(1, func.Results.Count);
            Assert.AreEqual(4, func.Body.Operations.Count); // matmul1, relu1, matmul2
        }

        [Test]
        public void BuildMLP_WithMultipleLayers()
        {
            var func = _module.CreateFunction("MLP");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var hiddenType = new TensorType(DataType.Float32, new[] { 32, 256 });
            var outputType = new TensorType(DataType.Float32, new[] { 32, 10 });

            var input = func.AddParameter(inputType, "x");
            var builder = new HLIRBuilder(func);

            var w1 = _module.Context.CreateValue(hiddenType, "w1");
            var b1 = _module.Context.CreateValue(new TensorType(DataType.Float32, new[] { 256 }), "b1");
            var h1 = builder.ReLU(builder.Add(builder.MatMul(input, w1), b1, "add1"));

            var w2 = _module.Context.CreateValue(outputType, "w2");
            var b2 = _module.Context.CreateValue(new TensorType(DataType.Float32, new[] { 10 }), "b2");
            var output = builder.Add(builder.MatMul(h1, w2), b2, "add2");

            func.SetResults(output);

            Assert.AreEqual(1, func.Parameters.Count);
            Assert.AreEqual(1, func.Results.Count);
        }

        [Test]
        public void HLIRGraphAnalyzer_BuildUseDefChains()
        {
            var func = _module.CreateFunction("TestFunc");
            var inputType = new TensorType(DataType.Float32, new[] { 32, 784 });
            var input = func.AddParameter(inputType, "x");

            var builder = new HLIRBuilder(func);
            var add1 = builder.Add(input, input, "add1");
            var add2 = builder.Add(add1, input, "add2");
            func.SetResults(add2);

            var chains = HLIRGraphAnalyzer.BuildUseDefChains(func);

            Assert.AreEqual(2, chains.Count);
            Assert.IsTrue(chains.ContainsKey(add1));
            Assert.IsTrue(chains.ContainsKey(add2));
        }
    }
}
